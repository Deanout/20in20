{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport morphdom from 'morphdom';\nvar activeElement;\nvar textInputTagNames = {\n  INPUT: true,\n  TEXTAREA: true,\n  SELECT: true\n};\nvar textInputTypes = {\n  'datetime-local': true,\n  'select-multiple': true,\n  'select-one': true,\n  color: true,\n  date: true,\n  datetime: true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  textarea: true,\n  time: true,\n  url: true,\n  week: true\n}; // Indicates if the passed element is considered a text input.\n//\n\nvar isTextInput = function isTextInput(element) {\n  return textInputTagNames[element.tagName] && textInputTypes[element.type];\n}; // Assigns focus to the appropriate element... preferring the explicitly passed focusSelector\n//\n// * focusSelector - a CSS selector for the element that should have focus\n//\n\n\nvar assignFocus = function assignFocus(focusSelector) {\n  var focusElement = focusSelector ? document.querySelector(focusSelector) : activeElement;\n  if (focusElement) focusElement.focus();\n}; // Dispatches an event on the passed element\n//\n// * element - the element\n// * name - the name of the event\n// * detail - the event detail\n//\n\n\nvar dispatch = function dispatch(element, name) {\n  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var init = {\n    bubbles: true,\n    cancelable: true\n  };\n  var evt = new Event(name, init);\n  evt.detail = detail;\n  element.dispatchEvent(evt);\n};\n\nvar xpathToElement = function xpathToElement(xpath) {\n  return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n}; // Indicates whether or not we should morph an element\n// SEE: https://github.com/patrick-steele-idem/morphdom#morphdomfromnode-tonode-options--node\n//\n\n\nvar shouldMorph = function shouldMorph(permanentAttributeName) {\n  return function (fromEl, toEl) {\n    // Skip nodes that are equal:\n    // https://github.com/patrick-steele-idem/morphdom#can-i-make-morphdom-blaze-through-the-dom-tree-even-faster-yes\n    if (fromEl.isEqualNode(toEl)) return false;\n    if (!permanentAttributeName) return true;\n    var permanent = fromEl.closest(\"[\".concat(permanentAttributeName, \"]\")); // only morph attributes on the active non-permanent text input\n\n    if (!permanent && isTextInput(fromEl) && fromEl === activeElement) {\n      var ignore = {\n        value: true\n      };\n      Array.from(toEl.attributes).forEach(function (attribute) {\n        if (!ignore[attribute.name]) fromEl.setAttribute(attribute.name, attribute.value);\n      });\n      return false;\n    }\n\n    return !permanent;\n  };\n}; // Morphdom Callbacks ........................................................................................\n\n\nvar DOMOperations = {\n  // Cookies .................................................................................................\n  setCookie: function setCookie(config) {\n    document.cookie = config.cookie;\n  },\n  // DOM Events ..............................................................................................\n  dispatchEvent: function dispatchEvent(config) {\n    var element = config.element,\n        name = config.name,\n        detail = config.detail;\n    dispatch(element, name, detail);\n  },\n  // Element Mutations .......................................................................................\n  morph: function morph(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        html = detail.html,\n        childrenOnly = detail.childrenOnly,\n        focusSelector = detail.focusSelector,\n        permanentAttributeName = detail.permanentAttributeName;\n    var template = document.createElement('template');\n    template.innerHTML = String(html).trim();\n    dispatch(element, 'cable-ready:before-morph', _objectSpread(_objectSpread({}, detail), {}, {\n      content: template.content\n    }));\n    morphdom(element, template.content, {\n      childrenOnly: !!childrenOnly,\n      onBeforeElUpdated: shouldMorph(permanentAttributeName)\n    });\n    assignFocus(focusSelector);\n    dispatch(element, 'cable-ready:after-morph', _objectSpread(_objectSpread({}, detail), {}, {\n      content: template.content\n    }));\n  },\n  innerHtml: function innerHtml(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        html = detail.html,\n        focusSelector = detail.focusSelector;\n    dispatch(element, 'cable-ready:before-inner-html', detail);\n    element.innerHTML = html;\n    assignFocus(focusSelector);\n    dispatch(element, 'cable-ready:after-inner-html', detail);\n  },\n  outerHtml: function outerHtml(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        html = detail.html,\n        focusSelector = detail.focusSelector;\n    dispatch(element, 'cable-ready:before-outer-html', detail);\n    element.outerHTML = html;\n    assignFocus(focusSelector);\n    dispatch(element, 'cable-ready:after-outer-html', detail);\n  },\n  textContent: function textContent(detail) {\n    var element = detail.element,\n        text = detail.text;\n    dispatch(element, 'cable-ready:before-text-content', detail);\n    element.textContent = text;\n    dispatch(element, 'cable-ready:after-text-content', detail);\n  },\n  insertAdjacentHtml: function insertAdjacentHtml(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        html = detail.html,\n        position = detail.position,\n        focusSelector = detail.focusSelector;\n    dispatch(element, 'cable-ready:before-insert-adjacent-html', detail);\n    element.insertAdjacentHTML(position || 'beforeend', html);\n    assignFocus(focusSelector);\n    dispatch(element, 'cable-ready:after-insert-adjacent-html', detail);\n  },\n  insertAdjacentText: function insertAdjacentText(detail) {\n    var element = detail.element,\n        text = detail.text,\n        position = detail.position;\n    dispatch(element, 'cable-ready:before-insert-adjacent-text', detail);\n    element.insertAdjacentText(position || 'beforeend', text);\n    dispatch(element, 'cable-ready:after-insert-adjacent-text', detail);\n  },\n  remove: function remove(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        focusSelector = detail.focusSelector;\n    dispatch(element, 'cable-ready:before-remove', detail);\n    element.remove();\n    assignFocus(focusSelector);\n    dispatch(element, 'cable-ready:after-remove', detail);\n  },\n  setValue: function setValue(detail) {\n    var element = detail.element,\n        value = detail.value;\n    dispatch(element, 'cable-ready:before-set-value', detail);\n    element.value = value;\n    dispatch(element, 'cable-ready:after-set-value', detail);\n  },\n  // Attribute Mutations .....................................................................................\n  setAttribute: function setAttribute(detail) {\n    var element = detail.element,\n        name = detail.name,\n        value = detail.value;\n    dispatch(element, 'cable-ready:before-set-attribute', detail);\n    element.setAttribute(name, value);\n    dispatch(element, 'cable-ready:after-set-attribute', detail);\n  },\n  removeAttribute: function removeAttribute(detail) {\n    var element = detail.element,\n        name = detail.name;\n    dispatch(element, 'cable-ready:before-remove-attribute', detail);\n    element.removeAttribute(name);\n    dispatch(element, 'cable-ready:after-remove-attribute', detail);\n  },\n  // CSS Class Mutations .....................................................................................\n  addCssClass: function addCssClass(detail) {\n    var element = detail.element,\n        name = detail.name;\n    dispatch(element, 'cable-ready:before-add-css-class', detail);\n    element.classList.add(name);\n    dispatch(element, 'cable-ready:after-add-css-class', detail);\n  },\n  removeCssClass: function removeCssClass(detail) {\n    var element = detail.element,\n        name = detail.name;\n    dispatch(element, 'cable-ready:before-remove-css-class', detail);\n    element.classList.remove(name);\n    dispatch(element, 'cable-ready:after-remove-css-class', detail);\n  },\n  // Style Mutations .......................................................................................\n  setStyle: function setStyle(detail) {\n    var element = detail.element,\n        name = detail.name,\n        value = detail.value;\n    dispatch(element, 'cable-ready:before-set-style', detail);\n    element.style[name] = value;\n    dispatch(element, 'cable-ready:after-set-style', detail);\n  },\n  // Dataset Mutations .......................................................................................\n  setDatasetProperty: function setDatasetProperty(detail) {\n    var element = detail.element,\n        name = detail.name,\n        value = detail.value;\n    dispatch(element, 'cable-ready:before-set-dataset-property', detail);\n    element.dataset[name] = value;\n    dispatch(element, 'cable-ready:after-set-dataset-property', detail);\n  }\n};\n\nvar perform = function perform(operations) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    emitMissingElementWarnings: true\n  };\n\n  for (var name in operations) {\n    if (operations.hasOwnProperty(name)) {\n      var entries = operations[name];\n\n      for (var i = 0; i < entries.length; i++) {\n        try {\n          var detail = entries[i];\n\n          if (detail.selector) {\n            detail.element = detail.xpath ? xpathToElement(detail.selector) : document.querySelector(detail.selector);\n          } else {\n            detail.element = document;\n          }\n\n          if (detail.element || options.emitMissingElementWarnings) DOMOperations[name](detail);\n        } catch (e) {\n          if (entries[i].element) console.log(\"CableReady detected an error in \".concat(name, \"! \").concat(e.message));else console.log(\"CableReady \".concat(name, \" failed due to missing DOM element.\"));\n        }\n      }\n    }\n  }\n};\n\nexport default {\n  perform: perform,\n  isTextInput: isTextInput\n};","map":null,"metadata":{},"sourceType":"module"}